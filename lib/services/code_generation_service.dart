import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../models/project_model.dart';
import '../models/screen_model.dart';
import '../models/widget_model.dart';
import '../core/constants/widget_types.dart';
import '../core/constants/app_constants.dart';

/// Service for generating Flutter code from widget models
class CodeGenerationService {
  /// Generate code for a single widget
  Future<String> generateWidgetCode(
    WidgetModel widget, {
    bool formatCode = true,
    bool includeComments = true,
    int indentLevel = 0,
  }) async {
    final buffer = StringBuffer();
    final indent = '  ' * indentLevel;

    if (includeComments) {
      buffer.writeln('$indent// ${widget.name} - ${widget.type.displayName}');
    }

    buffer.write(_generateWidgetInstance(widget, indentLevel));

    return formatCode ? _formatCode(buffer.toString()) : buffer.toString();
  }

  /// Generate code for a screen
  Future<String> generateScreenCode(
    ScreenModel screen, {
    bool formatCode = true,
    bool includeComments = true,
  }) async {
    final buffer = StringBuffer();

    // Add imports
    buffer.writeln(AppConstants.defaultImports);
    buffer.writeln();

    if (includeComments) {
      buffer.writeln('/// ${screen.name} Screen');
      if (screen.description?.isNotEmpty == true) {
        buffer.writeln('/// ${screen.description}');
      }
    }

    // Generate screen class
    final className = '${_toPascalCase(screen.name)}Screen';
    buffer.writeln('class $className extends StatelessWidget {');
    buffer.writeln('  const $className({super.key});');
    buffer.writeln();
    buffer.writeln('  @override');
    buffer.writeln('  Widget build(BuildContext context) {');
    buffer.writeln('    return Scaffold(');

    // Add app bar if enabled
    if (screen.showAppBar) {
      buffer.writeln('      appBar: AppBar(');
      buffer.writeln(
        '        title: Text(\'${screen.appBarTitle.isNotEmpty ? screen.appBarTitle : screen.name}\'),',
      );
      buffer.writeln('      ),');
    }

    // Add background color
    if (screen.backgroundColor != const Color(0xFFFFFFFF)) {
      buffer.writeln(
        '      backgroundColor: Color(0x${screen.backgroundColor.value.toRadixString(16).padLeft(8, '0').toUpperCase()}),',
      );
    }

    // Generate body
    buffer.writeln('      body: ${_generateScreenBody(screen)},');

    buffer.writeln('    );');
    buffer.writeln('  }');
    buffer.writeln('}');

    return formatCode ? _formatCode(buffer.toString()) : buffer.toString();
  }

  /// Generate complete Flutter app code
  Future<String> generateCompleteFlutterApp(
    ProjectModel project, {
    bool formatCode = true,
    bool includeComments = true,
  }) async {
    final buffer = StringBuffer();

    // Add imports
    buffer.writeln(AppConstants.defaultImports);
    buffer.writeln();

    if (includeComments) {
      buffer.writeln('/// ${project.name}');
      buffer.writeln('/// ${project.description}');
      buffer.writeln('/// Generated by ${AppConstants.appName}');
      buffer.writeln();
    }

    // Generate main function
    buffer.writeln('void main() {');
    buffer.writeln('  runApp(const MyApp());');
    buffer.writeln('}');
    buffer.writeln();

    // Generate app class
    buffer.writeln('class MyApp extends StatelessWidget {');
    buffer.writeln('  const MyApp({super.key});');
    buffer.writeln();
    buffer.writeln('  @override');
    buffer.writeln('  Widget build(BuildContext context) {');
    buffer.writeln('    return MaterialApp(');
    buffer.writeln('      title: \'${project.name}\',');

    // Add theme configuration
    final themeSettings = project.settings['theme'] as Map<String, dynamic>?;
    if (themeSettings != null) {
      buffer.writeln('      theme: ThemeData(');
      if (themeSettings['primaryColor'] != null) {
        buffer.writeln(
          '        primarySwatch: Colors.blue, // ${themeSettings['primaryColor']}',
        );
      }
      buffer.writeln('      ),');
    }

    buffer.writeln('      debugShowCheckedModeBanner: false,');

    // Set home screen
    final mainScreen = project.mainScreen;
    if (mainScreen != null) {
      final homeClassName = '${_toPascalCase(mainScreen.name)}Screen';
      buffer.writeln('      home: const $homeClassName(),');
    }

    buffer.writeln('    );');
    buffer.writeln('  }');
    buffer.writeln('}');
    buffer.writeln();

    // Generate all screen classes
    for (final screen in project.screens) {
      final screenCode = await generateScreenCode(
        screen,
        formatCode: false,
        includeComments: includeComments,
      );

      // Remove imports from screen code since they're already added
      final lines = screenCode.split('\n');
      final codeStart = lines.indexWhere((line) => line.startsWith('class '));
      if (codeStart >= 0) {
        buffer.writeln(lines.sublist(codeStart).join('\n'));
      }
    }

    return formatCode ? _formatCode(buffer.toString()) : buffer.toString();
  }

  /// Generate widget instance code
  String _generateWidgetInstance(WidgetModel widget, int indentLevel) {
    final indent = '  ' * indentLevel;
    final buffer = StringBuffer();

    switch (widget.type) {
      case FlutterWidgetType.container:
        buffer.write(_generateContainer(widget, indentLevel));
        break;
      case FlutterWidgetType.text:
        buffer.write(_generateText(widget, indentLevel));
        break;
      case FlutterWidgetType.elevatedButton:
        buffer.write(_generateElevatedButton(widget, indentLevel));
        break;
      case FlutterWidgetType.textField:
        buffer.write(_generateTextField(widget, indentLevel));
        break;
      case FlutterWidgetType.image:
        buffer.write(_generateImage(widget, indentLevel));
        break;
      case FlutterWidgetType.icon:
        buffer.write(_generateIcon(widget, indentLevel));
        break;
      case FlutterWidgetType.row:
        buffer.write(_generateRow(widget, indentLevel));
        break;
      case FlutterWidgetType.column:
        buffer.write(_generateColumn(widget, indentLevel));
        break;
      case FlutterWidgetType.stack:
        buffer.write(_generateStack(widget, indentLevel));
        break;
      case FlutterWidgetType.listView:
        buffer.write(_generateListView(widget, indentLevel));
        break;
      case FlutterWidgetType.card:
        buffer.write(_generateCard(widget, indentLevel));
        break;
      default:
        buffer.write('$indent${widget.type.displayName}()');
    }

    return buffer.toString();
  }

  /// Generate Container widget
  String _generateContainer(WidgetModel widget, int indentLevel) {
    final indent = '  ' * indentLevel;
    final props = widget.properties;
    final buffer = StringBuffer();

    buffer.writeln('${indent}Container(');

    if (props['width'] != null) {
      buffer.writeln('$indent  width: ${props['width']},');
    }
    if (props['height'] != null) {
      buffer.writeln('$indent  height: ${props['height']},');
    }
    if (props['padding'] != null) {
      buffer.writeln('$indent  padding: EdgeInsets.all(${props['padding']}),');
    }
    if (props['margin'] != null) {
      buffer.writeln('$indent  margin: EdgeInsets.all(${props['margin']}),');
    }
    if (props['color'] != null) {
      buffer.writeln(
        '$indent  color: Color(0x${(props['color'] as int).toRadixString(16).padLeft(8, '0').toUpperCase()}),',
      );
    }
    if (props['borderRadius'] != null) {
      buffer.writeln('$indent  decoration: BoxDecoration(');
      buffer.writeln(
        '$indent    borderRadius: BorderRadius.circular(${props['borderRadius']}),',
      );
      buffer.writeln('$indent  ),');
    }

    // Add children if any
    if (widget.children.isNotEmpty) {
      buffer.writeln(
        '$indent  child: ${_generateChildren(widget.children, indentLevel + 1)},',
      );
    }

    buffer.write('$indent)');
    return buffer.toString();
  }

  /// Generate Text widget
  String _generateText(WidgetModel widget, int indentLevel) {
    final indent = '  ' * indentLevel;
    final props = widget.properties;
    final buffer = StringBuffer();

    final text = props['text'] ?? 'Text';
    buffer.writeln('${indent}Text(');
    buffer.writeln('$indent  \'$text\',');

    if (props['fontSize'] != null ||
        props['fontWeight'] != null ||
        props['color'] != null) {
      buffer.writeln('$indent  style: TextStyle(');
      if (props['fontSize'] != null) {
        buffer.writeln('$indent    fontSize: ${props['fontSize']},');
      }
      if (props['fontWeight'] != null) {
        final weight = props['fontWeight'] == 'bold'
            ? 'FontWeight.bold'
            : 'FontWeight.normal';
        buffer.writeln('$indent    fontWeight: $weight,');
      }
      if (props['color'] != null) {
        buffer.writeln(
          '$indent    color: Color(0x${(props['color'] as int).toRadixString(16).padLeft(8, '0').toUpperCase()}),',
        );
      }
      buffer.writeln('$indent  ),');
    }

    if (props['textAlign'] != null) {
      final align = props['textAlign'];
      buffer.writeln('$indent  textAlign: TextAlign.$align,');
    }

    buffer.write('$indent)');
    return buffer.toString();
  }

  /// Generate ElevatedButton widget
  String _generateElevatedButton(WidgetModel widget, int indentLevel) {
    final indent = '  ' * indentLevel;
    final props = widget.properties;
    final buffer = StringBuffer();

    final text = props['text'] ?? 'Button';
    buffer.writeln('${indent}ElevatedButton(');
    buffer.writeln('$indent  onPressed: () {},');

    if (props['backgroundColor'] != null || props['foregroundColor'] != null) {
      buffer.writeln('$indent  style: ElevatedButton.styleFrom(');
      if (props['backgroundColor'] != null) {
        buffer.writeln(
          '$indent    backgroundColor: Color(0x${(props['backgroundColor'] as int).toRadixString(16).padLeft(8, '0').toUpperCase()}),',
        );
      }
      if (props['foregroundColor'] != null) {
        buffer.writeln(
          '$indent    foregroundColor: Color(0x${(props['foregroundColor'] as int).toRadixString(16).padLeft(8, '0').toUpperCase()}),',
        );
      }
      buffer.writeln('$indent  ),');
    }

    buffer.writeln('$indent  child: Text(\'$text\'),');
    buffer.write('$indent)');
    return buffer.toString();
  }

  /// Generate TextField widget
  String _generateTextField(WidgetModel widget, int indentLevel) {
    final indent = '  ' * indentLevel;
    final props = widget.properties;
    final buffer = StringBuffer();

    buffer.writeln('${indent}TextField(');

    if (props['hintText'] != null || props['labelText'] != null) {
      buffer.writeln('$indent  decoration: InputDecoration(');
      if (props['hintText'] != null) {
        buffer.writeln('$indent    hintText: \'${props['hintText']}\',');
      }
      if (props['labelText'] != null) {
        buffer.writeln('$indent    labelText: \'${props['labelText']}\',');
      }
      buffer.writeln('$indent  ),');
    }

    if (props['obscureText'] == true) {
      buffer.writeln('$indent  obscureText: true,');
    }

    buffer.write('$indent)');
    return buffer.toString();
  }

  /// Generate Image widget
  String _generateImage(WidgetModel widget, int indentLevel) {
    final indent = '  ' * indentLevel;
    final props = widget.properties;
    final buffer = StringBuffer();

    final src = props['src'] ?? 'assets/images/placeholder.png';
    buffer.writeln('${indent}Image.asset(');
    buffer.writeln('$indent  \'$src\',');

    if (props['width'] != null) {
      buffer.writeln('$indent  width: ${props['width']},');
    }
    if (props['height'] != null) {
      buffer.writeln('$indent  height: ${props['height']},');
    }
    if (props['fit'] != null) {
      buffer.writeln('$indent  fit: BoxFit.${props['fit']},');
    }

    buffer.write('$indent)');
    return buffer.toString();
  }

  /// Generate Icon widget
  String _generateIcon(WidgetModel widget, int indentLevel) {
    final indent = '  ' * indentLevel;
    final props = widget.properties;
    final buffer = StringBuffer();

    buffer.writeln('${indent}Icon(');
    buffer.writeln('$indent  Icons.star, // Icon code: ${props['icon']}');

    if (props['size'] != null) {
      buffer.writeln('$indent  size: ${props['size']},');
    }
    if (props['color'] != null) {
      buffer.writeln(
        '$indent  color: Color(0x${(props['color'] as int).toRadixString(16).padLeft(8, '0').toUpperCase()}),',
      );
    }

    buffer.write('$indent)');
    return buffer.toString();
  }

  /// Generate Row widget
  String _generateRow(WidgetModel widget, int indentLevel) {
    final indent = '  ' * indentLevel;
    final props = widget.properties;
    final buffer = StringBuffer();

    buffer.writeln('${indent}Row(');

    if (props['mainAxisAlignment'] != null) {
      buffer.writeln(
        '$indent  mainAxisAlignment: MainAxisAlignment.${props['mainAxisAlignment']},',
      );
    }
    if (props['crossAxisAlignment'] != null) {
      buffer.writeln(
        '$indent  crossAxisAlignment: CrossAxisAlignment.${props['crossAxisAlignment']},',
      );
    }

    if (widget.children.isNotEmpty) {
      buffer.writeln('$indent  children: [');
      for (int i = 0; i < widget.children.length; i++) {
        buffer.write(
          _generateWidgetInstance(widget.children[i], indentLevel + 2),
        );
        if (i < widget.children.length - 1) buffer.write(',');
        buffer.writeln();
      }
      buffer.writeln('$indent  ],');
    }

    buffer.write('$indent)');
    return buffer.toString();
  }

  /// Generate Column widget
  String _generateColumn(WidgetModel widget, int indentLevel) {
    final indent = '  ' * indentLevel;
    final props = widget.properties;
    final buffer = StringBuffer();

    buffer.writeln('${indent}Column(');

    if (props['mainAxisAlignment'] != null) {
      buffer.writeln(
        '$indent  mainAxisAlignment: MainAxisAlignment.${props['mainAxisAlignment']},',
      );
    }
    if (props['crossAxisAlignment'] != null) {
      buffer.writeln(
        '$indent  crossAxisAlignment: CrossAxisAlignment.${props['crossAxisAlignment']},',
      );
    }

    if (widget.children.isNotEmpty) {
      buffer.writeln('$indent  children: [');
      for (int i = 0; i < widget.children.length; i++) {
        buffer.write(
          _generateWidgetInstance(widget.children[i], indentLevel + 2),
        );
        if (i < widget.children.length - 1) buffer.write(',');
        buffer.writeln();
      }
      buffer.writeln('$indent  ],');
    }

    buffer.write('$indent)');
    return buffer.toString();
  }

  /// Generate Stack widget
  String _generateStack(WidgetModel widget, int indentLevel) {
    final indent = '  ' * indentLevel;
    final buffer = StringBuffer();

    buffer.writeln('${indent}Stack(');

    if (widget.children.isNotEmpty) {
      buffer.writeln('$indent  children: [');
      for (int i = 0; i < widget.children.length; i++) {
        buffer.write(
          _generateWidgetInstance(widget.children[i], indentLevel + 2),
        );
        if (i < widget.children.length - 1) buffer.write(',');
        buffer.writeln();
      }
      buffer.writeln('$indent  ],');
    }

    buffer.write('$indent)');
    return buffer.toString();
  }

  /// Generate ListView widget
  String _generateListView(WidgetModel widget, int indentLevel) {
    final indent = '  ' * indentLevel;
    final props = widget.properties;
    final buffer = StringBuffer();

    buffer.writeln('${indent}ListView(');

    if (props['padding'] != null) {
      buffer.writeln('$indent  padding: EdgeInsets.all(${props['padding']}),');
    }

    buffer.writeln('$indent  children: [');
    // Generate placeholder items
    final itemCount = props['itemCount'] ?? 5;
    for (int i = 0; i < itemCount; i++) {
      buffer.writeln('$indent    ListTile(');
      buffer.writeln('$indent      title: Text(\'Item ${i + 1}\'),');
      buffer.writeln('$indent    ),');
    }
    buffer.writeln('$indent  ],');

    buffer.write('$indent)');
    return buffer.toString();
  }

  /// Generate Card widget
  String _generateCard(WidgetModel widget, int indentLevel) {
    final indent = '  ' * indentLevel;
    final props = widget.properties;
    final buffer = StringBuffer();

    buffer.writeln('${indent}Card(');

    if (props['elevation'] != null) {
      buffer.writeln('$indent  elevation: ${props['elevation']},');
    }
    if (props['margin'] != null) {
      buffer.writeln('$indent  margin: EdgeInsets.all(${props['margin']}),');
    }

    if (widget.children.isNotEmpty) {
      buffer.writeln(
        '$indent  child: ${_generateChildren(widget.children, indentLevel + 1)},',
      );
    }

    buffer.write('$indent)');
    return buffer.toString();
  }

  /// Generate children widgets
  String _generateChildren(List<WidgetModel> children, int indentLevel) {
    if (children.isEmpty) return 'Container()';
    if (children.length == 1) {
      return _generateWidgetInstance(children.first, 0).trim();
    }

    final buffer = StringBuffer();
    buffer.writeln('Column(');
    buffer.writeln('  children: [');
    for (int i = 0; i < children.length; i++) {
      buffer.write(_generateWidgetInstance(children[i], 2));
      if (i < children.length - 1) buffer.write(',');
      buffer.writeln();
    }
    buffer.writeln('  ],');
    buffer.write(')');
    return buffer.toString();
  }

  /// Generate screen body
  String _generateScreenBody(ScreenModel screen) {
    if (screen.widgets.isEmpty) {
      return 'const Center(child: Text(\'Empty Screen\'))';
    }

    if (screen.widgets.length == 1) {
      return _generateWidgetInstance(screen.widgets.first, 0).trim();
    }

    final buffer = StringBuffer();
    buffer.writeln('Column(');
    buffer.writeln('      children: [');
    for (int i = 0; i < screen.widgets.length; i++) {
      buffer.write(_generateWidgetInstance(screen.widgets[i], 4));
      if (i < screen.widgets.length - 1) buffer.write(',');
      buffer.writeln();
    }
    buffer.writeln('      ],');
    buffer.write('    )');
    return buffer.toString();
  }

  /// Convert string to PascalCase
  String _toPascalCase(String input) {
    return input
        .split(RegExp(r'[\s_-]+'))
        .map(
          (word) => word.isEmpty
              ? ''
              : word[0].toUpperCase() + word.substring(1).toLowerCase(),
        )
        .join();
  }

  /// Format code (basic formatting)
  String _formatCode(String code) {
    // Basic code formatting - in a real implementation, you'd use dart_style
    final lines = code.split('\n');
    final formatted = <String>[];

    for (final line in lines) {
      final trimmed = line.trim();
      if (trimmed.isNotEmpty) {
        formatted.add(line);
      }
    }

    return formatted.join('\n');
  }
}

/// Code generation service provider
final codeGenerationServiceProvider = Provider<CodeGenerationService>((ref) {
  return CodeGenerationService();
});
