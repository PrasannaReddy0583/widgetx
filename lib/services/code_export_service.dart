import 'dart:convert';
import 'package:flutter/material.dart';
import '../models/widget_model.dart';
import '../core/constants/widget_types.dart';

/// Service for exporting Flutter code from widget models
class CodeExportService {
  static const String _indent = '  ';

  /// Export complete Flutter app code
  static String exportFlutterApp({
    required List<WidgetModel> widgets,
    required String appName,
    String? packageName,
  }) {
    final mainDartCode = _generateMainDart(appName);
    final homePageCode = _generateHomePage(widgets);

    return '''
// Generated by WidgetX - Flutter App Builder
// App: $appName
// Generated on: ${DateTime.now().toIso8601String()}

$mainDartCode

$homePageCode
''';
  }

  /// Generate main.dart file content
  static String _generateMainDart(String appName) {
    return '''
import 'package:flutter/material.dart';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: '$appName',
      theme: ThemeData(
        primarySwatch: Colors.blue,
        visualDensity: VisualDensity.adaptivePlatformDensity,
      ),
      home: HomePage(),
      debugShowCheckedModeBanner: false,
    );
  }
}''';
  }

  /// Generate home page with all widgets
  static String _generateHomePage(List<WidgetModel> widgets) {
    final widgetCode = _generateWidgetTree(widgets, 0);

    return '''
class HomePage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Stack(
        children: [
$widgetCode
        ],
      ),
    );
  }
}''';
  }

  /// Generate widget tree code
  static String _generateWidgetTree(
    List<WidgetModel> widgets,
    int indentLevel,
  ) {
    final buffer = StringBuffer();
    final indent = _indent * (indentLevel + 3);

    for (final widget in widgets) {
      if (!widget.isVisible) continue;

      buffer.writeln(
        '$indent${_generatePositionedWidget(widget, indentLevel + 1)},',
      );
    }

    return buffer.toString();
  }

  /// Generate Positioned widget wrapper
  static String _generatePositionedWidget(WidgetModel widget, int indentLevel) {
    final indent = _indent * indentLevel;
    final childIndent = _indent * (indentLevel + 1);

    return '''Positioned(
${childIndent}left: ${widget.position.dx},
${childIndent}top: ${widget.position.dy},
${childIndent}child: ${_generateWidget(widget, indentLevel + 1)},
$indent)''';
  }

  /// Generate individual widget code
  static String _generateWidget(WidgetModel widget, int indentLevel) {
    switch (widget.type) {
      case FlutterWidgetType.container:
        return _generateContainer(widget, indentLevel);
      case FlutterWidgetType.text:
        return _generateText(widget, indentLevel);
      case FlutterWidgetType.elevatedButton:
        return _generateButton(widget, indentLevel);
      case FlutterWidgetType.row:
        return _generateRow(widget, indentLevel);
      case FlutterWidgetType.column:
        return _generateColumn(widget, indentLevel);
      case FlutterWidgetType.stack:
        return _generateStack(widget, indentLevel);
      case FlutterWidgetType.image:
        return _generateImage(widget, indentLevel);
      case FlutterWidgetType.icon:
        return _generateIcon(widget, indentLevel);
      default:
        return _generateContainer(widget, indentLevel);
    }
  }

  /// Generate Container widget code
  static String _generateContainer(WidgetModel widget, int indentLevel) {
    final indent = _indent * indentLevel;
    final childIndent = _indent * (indentLevel + 1);
    final buffer = StringBuffer();

    buffer.writeln('Container(');

    // Size
    final width = widget.properties['width'] ?? widget.size.width;
    final height = widget.properties['height'] ?? widget.size.height;
    buffer.writeln('${childIndent}width: $width,');
    buffer.writeln('${childIndent}height: $height,');

    // Decoration
    final decorationProps = <String>[];

    // Color
    final color = widget.properties['color'];
    if (color != null) {
      decorationProps.add('${childIndent}color: ${_formatColor(color)},');
    }

    // Border radius
    final borderRadius = widget.properties['borderRadius'];
    if (borderRadius != null && borderRadius > 0) {
      decorationProps.add(
        '${childIndent}borderRadius: BorderRadius.circular($borderRadius),',
      );
    }

    if (decorationProps.isNotEmpty) {
      buffer.writeln('${childIndent}decoration: BoxDecoration(');
      for (final prop in decorationProps) {
        buffer.writeln('$childIndent$prop');
      }
      buffer.writeln('$childIndent),');
    }

    // Padding
    final padding = widget.properties['padding'];
    if (padding != null) {
      buffer.writeln('${childIndent}padding: ${_formatEdgeInsets(padding)},');
    }

    // Margin
    final margin = widget.properties['margin'];
    if (margin != null) {
      buffer.writeln('${childIndent}margin: ${_formatEdgeInsets(margin)},');
    }

    // Children
    if (widget.children.isNotEmpty) {
      buffer.writeln(
        '${childIndent}child: ${_generateChildWidget(widget.children.first, indentLevel + 1)},',
      );
    }

    buffer.write('$indent)');
    return buffer.toString();
  }

  /// Generate Text widget code
  static String _generateText(WidgetModel widget, int indentLevel) {
    final indent = _indent * indentLevel;
    final childIndent = _indent * (indentLevel + 1);
    final buffer = StringBuffer();

    final text = widget.properties['text'] ?? 'Text';
    buffer.writeln('Text(');
    buffer.writeln('$childIndent\'${_escapeString(text)}\',');

    // Style
    final styleProps = <String>[];

    final fontSize = widget.properties['fontSize'];
    if (fontSize != null) {
      styleProps.add('fontSize: $fontSize');
    }

    final color = widget.properties['color'];
    if (color != null) {
      styleProps.add('color: ${_formatColor(color)}');
    }

    final fontWeight = widget.properties['fontWeight'];
    if (fontWeight != null && fontWeight != 'normal') {
      styleProps.add('fontWeight: ${_formatFontWeight(fontWeight)}');
    }

    if (styleProps.isNotEmpty) {
      buffer.writeln('${childIndent}style: TextStyle(');
      for (int i = 0; i < styleProps.length; i++) {
        final comma = i < styleProps.length - 1 ? ',' : '';
        buffer.writeln('$childIndent$_indent${styleProps[i]}$comma');
      }
      buffer.writeln('$childIndent),');
    }

    // Text alignment
    final textAlign = widget.properties['textAlign'];
    if (textAlign != null && textAlign != 'left') {
      buffer.writeln(
        '${childIndent}textAlign: ${_formatTextAlign(textAlign)},',
      );
    }

    buffer.write('$indent)');
    return buffer.toString();
  }

  /// Generate Button widget code
  static String _generateButton(WidgetModel widget, int indentLevel) {
    final indent = _indent * indentLevel;
    final childIndent = _indent * (indentLevel + 1);
    final buffer = StringBuffer();

    final text = widget.properties['text'] ?? 'Button';
    buffer.writeln('ElevatedButton(');
    buffer.writeln('${childIndent}onPressed: () {');
    buffer.writeln('$childIndent$_indent// TODO: Add button action');
    buffer.writeln('$childIndent},');

    // Style
    final color = widget.properties['color'];
    if (color != null) {
      buffer.writeln('${childIndent}style: ElevatedButton.styleFrom(');
      buffer.writeln(
        '$childIndent${_indent}backgroundColor: ${_formatColor(color)},',
      );
      buffer.writeln('$childIndent),');
    }

    buffer.writeln('${childIndent}child: Text(\'${_escapeString(text)}\'),');
    buffer.write('$indent)');
    return buffer.toString();
  }

  /// Generate Row widget code
  static String _generateRow(WidgetModel widget, int indentLevel) {
    final indent = _indent * indentLevel;
    final childIndent = _indent * (indentLevel + 1);
    final buffer = StringBuffer();

    buffer.writeln('Row(');

    // Main axis alignment
    final mainAxisAlignment = widget.properties['mainAxisAlignment'];
    if (mainAxisAlignment != null && mainAxisAlignment != 'start') {
      buffer.writeln(
        '${childIndent}mainAxisAlignment: ${_formatMainAxisAlignment(mainAxisAlignment)},',
      );
    }

    // Cross axis alignment
    final crossAxisAlignment = widget.properties['crossAxisAlignment'];
    if (crossAxisAlignment != null && crossAxisAlignment != 'center') {
      buffer.writeln(
        '${childIndent}crossAxisAlignment: ${_formatCrossAxisAlignment(crossAxisAlignment)},',
      );
    }

    // Children
    if (widget.children.isNotEmpty) {
      buffer.writeln('${childIndent}children: [');
      for (final child in widget.children) {
        buffer.writeln(
          '$childIndent$_indent${_generateChildWidget(child, indentLevel + 2)},',
        );
      }
      buffer.writeln('$childIndent],');
    }

    buffer.write('$indent)');
    return buffer.toString();
  }

  /// Generate Column widget code
  static String _generateColumn(WidgetModel widget, int indentLevel) {
    final indent = _indent * indentLevel;
    final childIndent = _indent * (indentLevel + 1);
    final buffer = StringBuffer();

    buffer.writeln('Column(');

    // Main axis alignment
    final mainAxisAlignment = widget.properties['mainAxisAlignment'];
    if (mainAxisAlignment != null && mainAxisAlignment != 'start') {
      buffer.writeln(
        '${childIndent}mainAxisAlignment: ${_formatMainAxisAlignment(mainAxisAlignment)},',
      );
    }

    // Cross axis alignment
    final crossAxisAlignment = widget.properties['crossAxisAlignment'];
    if (crossAxisAlignment != null && crossAxisAlignment != 'center') {
      buffer.writeln(
        '${childIndent}crossAxisAlignment: ${_formatCrossAxisAlignment(crossAxisAlignment)},',
      );
    }

    // Children
    if (widget.children.isNotEmpty) {
      buffer.writeln('${childIndent}children: [');
      for (final child in widget.children) {
        buffer.writeln(
          '$childIndent$_indent${_generateChildWidget(child, indentLevel + 2)},',
        );
      }
      buffer.writeln('$childIndent],');
    }

    buffer.write('$indent)');
    return buffer.toString();
  }

  /// Generate Stack widget code
  static String _generateStack(WidgetModel widget, int indentLevel) {
    final indent = _indent * indentLevel;
    final childIndent = _indent * (indentLevel + 1);
    final buffer = StringBuffer();

    buffer.writeln('Stack(');

    // Alignment
    final alignment = widget.properties['alignment'];
    if (alignment != null && alignment != 'topLeft') {
      buffer.writeln(
        '${childIndent}alignment: ${_formatAlignment(alignment)},',
      );
    }

    // Children
    if (widget.children.isNotEmpty) {
      buffer.writeln('${childIndent}children: [');
      for (final child in widget.children) {
        buffer.writeln(
          '$childIndent$_indent${_generateChildWidget(child, indentLevel + 2)},',
        );
      }
      buffer.writeln('$childIndent],');
    }

    buffer.write('$indent)');
    return buffer.toString();
  }

  /// Generate Image widget code
  static String _generateImage(WidgetModel widget, int indentLevel) {
    final indent = _indent * indentLevel;
    final childIndent = _indent * (indentLevel + 1);
    final buffer = StringBuffer();

    final src = widget.properties['src'] ?? '';

    if (src.startsWith('http')) {
      buffer.writeln('Image.network(');
      buffer.writeln('$childIndent\'$src\',');
    } else if (src.isNotEmpty) {
      buffer.writeln('Image.asset(');
      buffer.writeln('$childIndent\'$src\',');
    } else {
      buffer.writeln('Container(');
      buffer.writeln('${childIndent}color: Colors.grey[300],');
      buffer.writeln('${childIndent}child: Icon(Icons.image, size: 48),');
    }

    // Fit
    final fit = widget.properties['fit'];
    if (fit != null && fit != 'cover') {
      buffer.writeln('${childIndent}fit: ${_formatBoxFit(fit)},');
    }

    buffer.write('$indent)');
    return buffer.toString();
  }

  /// Generate Icon widget code
  static String _generateIcon(WidgetModel widget, int indentLevel) {
    final indent = _indent * indentLevel;
    final childIndent = _indent * (indentLevel + 1);
    final buffer = StringBuffer();

    final iconCode = widget.properties['icon'] ?? Icons.star.codePoint;
    buffer.writeln('Icon(');
    buffer.writeln(
      '${childIndent}IconData($iconCode, fontFamily: \'MaterialIcons\'),',
    );

    final size = widget.properties['size'];
    if (size != null) {
      buffer.writeln('${childIndent}size: $size,');
    }

    final color = widget.properties['color'];
    if (color != null) {
      buffer.writeln('${childIndent}color: ${_formatColor(color)},');
    }

    buffer.write('$indent)');
    return buffer.toString();
  }

  /// Generate child widget (for nested widgets)
  static String _generateChildWidget(WidgetModel widget, int indentLevel) {
    return _generateWidget(widget, indentLevel);
  }

  // Formatting helper methods

  static String _formatColor(dynamic color) {
    if (color is int) {
      return 'Color(0x${color.toRadixString(16).padLeft(8, '0').toUpperCase()})';
    }
    return 'Colors.blue';
  }

  static String _formatEdgeInsets(dynamic value) {
    if (value is double || value is int) {
      return 'EdgeInsets.all($value)';
    }
    if (value is Map) {
      final left = value['left'] ?? 0;
      final top = value['top'] ?? 0;
      final right = value['right'] ?? 0;
      final bottom = value['bottom'] ?? 0;
      return 'EdgeInsets.fromLTRB($left, $top, $right, $bottom)';
    }
    return 'EdgeInsets.zero';
  }

  static String _formatFontWeight(String weight) {
    switch (weight) {
      case 'bold':
        return 'FontWeight.bold';
      case 'w100':
        return 'FontWeight.w100';
      case 'w200':
        return 'FontWeight.w200';
      case 'w300':
        return 'FontWeight.w300';
      case 'w400':
        return 'FontWeight.w400';
      case 'w500':
        return 'FontWeight.w500';
      case 'w600':
        return 'FontWeight.w600';
      case 'w700':
        return 'FontWeight.w700';
      case 'w800':
        return 'FontWeight.w800';
      case 'w900':
        return 'FontWeight.w900';
      default:
        return 'FontWeight.normal';
    }
  }

  static String _formatTextAlign(String align) {
    switch (align) {
      case 'center':
        return 'TextAlign.center';
      case 'right':
        return 'TextAlign.right';
      case 'justify':
        return 'TextAlign.justify';
      case 'start':
        return 'TextAlign.start';
      case 'end':
        return 'TextAlign.end';
      default:
        return 'TextAlign.left';
    }
  }

  static String _formatMainAxisAlignment(String alignment) {
    switch (alignment) {
      case 'center':
        return 'MainAxisAlignment.center';
      case 'end':
        return 'MainAxisAlignment.end';
      case 'spaceBetween':
        return 'MainAxisAlignment.spaceBetween';
      case 'spaceAround':
        return 'MainAxisAlignment.spaceAround';
      case 'spaceEvenly':
        return 'MainAxisAlignment.spaceEvenly';
      default:
        return 'MainAxisAlignment.start';
    }
  }

  static String _formatCrossAxisAlignment(String alignment) {
    switch (alignment) {
      case 'center':
        return 'CrossAxisAlignment.center';
      case 'end':
        return 'CrossAxisAlignment.end';
      case 'stretch':
        return 'CrossAxisAlignment.stretch';
      case 'baseline':
        return 'CrossAxisAlignment.baseline';
      default:
        return 'CrossAxisAlignment.start';
    }
  }

  static String _formatAlignment(String alignment) {
    switch (alignment) {
      case 'center':
        return 'Alignment.center';
      case 'topCenter':
        return 'Alignment.topCenter';
      case 'topRight':
        return 'Alignment.topRight';
      case 'centerLeft':
        return 'Alignment.centerLeft';
      case 'centerRight':
        return 'Alignment.centerRight';
      case 'bottomLeft':
        return 'Alignment.bottomLeft';
      case 'bottomCenter':
        return 'Alignment.bottomCenter';
      case 'bottomRight':
        return 'Alignment.bottomRight';
      default:
        return 'Alignment.topLeft';
    }
  }

  static String _formatBoxFit(String fit) {
    switch (fit) {
      case 'contain':
        return 'BoxFit.contain';
      case 'fill':
        return 'BoxFit.fill';
      case 'fitWidth':
        return 'BoxFit.fitWidth';
      case 'fitHeight':
        return 'BoxFit.fitHeight';
      case 'none':
        return 'BoxFit.none';
      case 'scaleDown':
        return 'BoxFit.scaleDown';
      default:
        return 'BoxFit.cover';
    }
  }

  static String _escapeString(String str) {
    return str.replaceAll('\'', '\\\'').replaceAll('\n', '\\n');
  }

  /// Generate pubspec.yaml content
  static String generatePubspec({
    required String appName,
    String? description,
    String version = '1.0.0+1',
  }) {
    final packageName = appName.toLowerCase().replaceAll(' ', '_');

    return '''
name: $packageName
description: ${description ?? 'A Flutter application generated by WidgetX'}
version: $version

environment:
  sdk: '>=3.0.0 <4.0.0'
  flutter: ">=3.10.0"

dependencies:
  flutter:
    sdk: flutter
  cupertino_icons: ^1.0.6

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^3.0.0

flutter:
  uses-material-design: true
  
  # To add assets to your application, add an assets section, like this:
  # assets:
  #   - images/a_dot_burr.jpeg
  #   - images/a_dot_ham.jpeg

  # To add custom fonts to your application, add a fonts section here,
  # in this "flutter" section. Each entry in this list should have a
  # "family" key with the font family name, and a "fonts" key with a
  # list giving the asset and other descriptors for the font.
''';
  }

  /// Generate README.md content
  static String generateReadme({required String appName, String? description}) {
    return '''
# $appName

${description ?? 'A Flutter application generated by WidgetX - Flutter App Builder'}

## Getting Started

This Flutter project was generated using WidgetX, a visual Flutter app builder.

### Prerequisites

- Flutter SDK (>=3.10.0)
- Dart SDK (>=3.0.0)

### Installation

1. Clone or download this project
2. Navigate to the project directory
3. Run `flutter pub get` to install dependencies
4. Run `flutter run` to start the app

### Building for Production

- **Android**: `flutter build apk --release`
- **iOS**: `flutter build ios --release`
- **Web**: `flutter build web --release`

## Generated by WidgetX

This app was created using WidgetX - Flutter App Builder, a visual tool for creating Flutter applications without writing code.

For more information about WidgetX, visit: [WidgetX Documentation]

## License

This project is licensed under the MIT License.
''';
  }
}
